<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>networking on Lucas&#39; Refuge</title>
    <link>http://www.x8lucas8x.com/tags/networking/</link>
    <description>Recent content in networking on Lucas&#39; Refuge</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Sep 2015 19:30:00 +0000</lastBuildDate>
    <atom:link href="http://www.x8lucas8x.com/tags/networking/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Connected, but still not interoperable</title>
      <link>http://www.x8lucas8x.com/post/connectedButStillNotInteroperable/</link>
      <pubDate>Fri, 04 Sep 2015 19:30:00 +0000</pubDate>
      
      <guid>http://www.x8lucas8x.com/post/connectedButStillNotInteroperable/</guid>
      <description>&lt;hr /&gt;

&lt;p&gt;Cisco call it the Internet of Everything (IoE), most players would rather
name it the Internet of Things (IoT) and, although less common, you probably
heard the term the Industrial Internet too. And if you ever read any post
or whitepaper about one of those buzzwords, especially those written by big
players in the market (e.g. Cisco, IBM), you probably saw a trend in
depicting scenarios where your things (e.g. car, appliances, lighting, HVAC)
are interconnected and, somehow, interacting among themselves independently
of human interference. Great vision, but how far are we from it?&lt;/p&gt;

&lt;p&gt;Right now IoT is composed by a jungle of different solutions. You can probably outline
those that seem more promising. In the networking spectrum there is a whole stack
solutions, which tries to provide you not only data link layer features but also
routing, addressing and some even encryption, those are mainly Zigbee, Z-Wave,
Bluetooth and WirelessHart. On the other hand you also have WIFI, raw IEEE 802.15.4,
GPRS and all sort of radios operating in sub-gigahertz frequency ranges. Each has
an use case of its own. Z-Wave, for instance, is more present in home automation,
Bluetooth V4 is usually the right one for wearables, WirelessHart is an adaption
of the Highway Addressable Remote Transducer Protocol (HART) protocol for industrial
wireless networks and Zigbee is the wild card among them (i.e. thanks to DIGI&amp;rsquo;s
amazing AT programming interface).&lt;/p&gt;

&lt;p&gt;Along with that there is also efforts to bring the IP protocol to the constrained devices
like those that use IEEE 802.15.4 and its variations. Well, the advantages are many. First
there is the seamless exchange of information between devices utilizing any IP-enabled
MAC/PHY (e.g. Wi-Fi, Ethernet). Second we cannot forget the battle-tested tooling all
those years of IP predominance have provided us (e.g. ping, traceroute, netcat, wireshark,
tcpdump). The &lt;a href=&#34;http://www.ipso-alliance.org/&#34;&gt;IPSO Alliance&lt;/a&gt; is one of the major advocates in this matter. They have several
whitepapers publicising standards like &lt;a href=&#34;http://www.ipso-alliance.org/downloads/6LoWPAN&#34;&gt;6LowPan&lt;/a&gt;, an IPV6-compatible addressing with better
header compression, and &lt;a href=&#34;http://www.ipso-alliance.org/downloads/RPL&#34;&gt;RPL&lt;/a&gt;, a mesh-enabled routing protocol for low power and lossy networks.
The &lt;a href=&#34;http://www.zigbee.org/&#34;&gt;Zigbee Alliance&lt;/a&gt; also realised the advantages of IPv6-based wireless mesh networking and
created ZigBee IP, and open standard built on top of IEEE 802.15.4 that provides end-to-end
IPv6 networking.&lt;/p&gt;

&lt;p&gt;On top of IP, on the application level, &lt;a href=&#34;http://mqtt.org/news&#34;&gt;MQTT&lt;/a&gt; and &lt;a href=&#34;https://tools.ietf.org/html/rfc7252&#34;&gt;COAP&lt;/a&gt; shine. The first is a lightweight
PUB-SUB protocol based on TCP. Now you may wonder if &lt;a href=&#34;http://mqtt.org/news&#34;&gt;MQTT&lt;/a&gt; is appropriate for wireless
sensor networks. In fact anything TCP based is not by design, but in such cases you can use
&lt;a href=&#34;http://mqtt.org/news&#34;&gt;MQTT-SN&lt;/a&gt;, a UDP based variation of &lt;a href=&#34;http://mqtt.org/news&#34;&gt;MQTT&lt;/a&gt; that is especially tailored for low-cost and
low-power sensor devices that run over bandwidth-constrained wireless networks. While &lt;a href=&#34;https://tools.ietf.org/html/rfc7252&#34;&gt;COAP&lt;/a&gt;
is a lightweight HTTP compatible protocol, based on UDP, with support for multicasting and
service discovery. Both of them are quite popular and you can probably find an implementation
for your favourite programming language or IoT platform (e.g. &lt;a href=&#34;http://contiki-os.org/&#34;&gt;Contiki OS&lt;/a&gt;, &lt;a href=&#34;https://tools.ietf.org/html/rfc7390&#34;&gt;Arduino&lt;/a&gt;).
Unfortunately, given a non-IP network, developing a gateway to map your custom protocol
in the interface your backend/server uses and vice-versa is a necessary burden.&lt;/p&gt;

&lt;p&gt;So, there is certainly no doubt there were major progresses on the connectivity front, but
still something is absent in this equation. Connectivity is certainly necessary but IoT is as
much about connectivity as the internet is about the web. That vision those big players describe
of smart Xs, being X anything, autonomously interacting among themselves is heavily dependent
of those devices being able to discover each other and access their functionalities, without
being explicitly pre-programmed to do so. You probably saw companies like &lt;a href=&#34;http://www.smartthings.com/&#34;&gt;Smart Things&lt;/a&gt;,
&lt;a href=&#34;https://ninjablocks.com/&#34;&gt;Ninja Blocks&lt;/a&gt; or the former &lt;a href=&#34;http://revolv.com/&#34;&gt;Revolv&lt;/a&gt;, bought by &lt;a href=&#34;https://nest.com/&#34;&gt;Nest&lt;/a&gt;, stating that their platforms/hubs
supports different vendors or &amp;ldquo;play well with others&amp;rdquo;, which is great but has its own limitations.&lt;/p&gt;

&lt;p&gt;Up to now, in platforms like the aforementioned, integration of new products occurs in a
incremental fashion. So if you want to support Phillip&amp;rsquo;s &lt;a href=&#34;http://www2.meethue.com/pt-br/&#34;&gt;Hue&lt;/a&gt; or &lt;a href=&#34;https://www.lifx.com/&#34;&gt;LIFX&lt;/a&gt; lamps, you will have
to read the documentation of their REST API. Which seems great given REST apis are easy to
integrate, but the crude reality of IoT is way less welcoming. In most you cases, you will
find yourself with vertically integrated systems that do not permit easy third-party integration.
And even if they permitted, the manual process of integrating with new devices and/or platforms
have two problems.&lt;/p&gt;

&lt;p&gt;First, a great deal of products does not provide public documented APIs for third-parties.
And the reason is that, currently, most vendors tend to sell a solution, from hardware to user
interface, therefore not caring for those who want to use their products differently from what
they envisaged (i.e. makers suffer :/). Consider &lt;a href=&#34;https://www.plugwise.com/&#34;&gt;Plugwise&lt;/a&gt;, for instance, they have one of the
most complete energy management solutions out there, but without a consistent effor to provide
a public API or SDK. You may even find unofficial libraries, made by someone who probably had
to sniffer &lt;a href=&#34;https://www.plugwise.com/&#34;&gt;Plugwise&lt;/a&gt;&amp;rsquo;s devices in order to reverse engineer their proprietary protocol. But
using those, you would not have any guarantee of future support. Besides that it is common
for unofficial libraries not to be feature complete, so good luck if you want to use the most
recent capabilities.&lt;/p&gt;

&lt;p&gt;Second, manual integration does not scale. Vendors may try to pinpoint the most popular
products, to focus their integrations efforts, or form partnerships, but that degree of
interoperability will come at the expense of tight vendor integration with specific
partners.&lt;/p&gt;

&lt;p&gt;To solve those problems, devices need to discover and access each other functionalities, not
necessarily directly like M2M scenarios portrait. And for such two things are required. First
a data model that could explicitly state what each piece of data is about, so that you do not
have to read a manual to realise that a sensor is measuring temperature in Celsius. Ontologies
are usually the answer in such cases, but &lt;a href=&#34;http://www.w3.org/2001/sw/wiki/OWL&#34;&gt;OWL&lt;/a&gt; and &lt;a href=&#34;http://www.w3.org/2001/sw/wiki/RDF&#34;&gt;RDF&lt;/a&gt; are not appropriate given the bandwidth
limitations. The &lt;a href=&#34;http://www.ipso-alliance.org/&#34;&gt;IPSO Alliance&lt;/a&gt; tried to fill this gap with its &lt;a href=&#34;http://www.ipso-alliance.org/smart-object-guidelines&#34;&gt;Smart Objects&lt;/a&gt; specification,
which describes a reusable data model for IoT. That data model defines a set of data types
and structures that can be used by different devices, in order to enable them to interoperate
since the semantics is now in the data itself. Still, despite the &lt;a href=&#34;http://www.ipso-alliance.org/smart-object-guidelines&#34;&gt;Smart Objects&lt;/a&gt; specification,
ontologies have an important role at the users level, as the tooling from semantic web
technologies (e.g. &lt;a href=&#34;http://www.w3.org/2001/sw/wiki/SPARQL&#34;&gt;SPARQL&lt;/a&gt;, &lt;a href=&#34;http://www.w3.org/2001/sw/wiki/OWL&#34;&gt;OWL&lt;/a&gt;, &lt;a href=&#34;http://www.w3.org/2001/sw/wiki/RDF&#34;&gt;RDF&lt;/a&gt;) can provide great value for those interested in
composing their own IoT solutions by accessing higher level services.&lt;/p&gt;

&lt;p&gt;Although being able to determine the content of the messages sent by sensors is important, no
equivalent exists in terms of actuation. And that is key to a large adoption of IoT, especially
in the end-consumer market. Right now, businesses can get value by tracking trends and analysing
data, but for end-consumers automation is the real killer application. And by automation I mean
not only actuation, that translates itself in an event in the physical world, but also remote
configuration of these devices. All that provided, without devices being pre-programmed to do
so, would be huge. But, unfortunately, no lightweight UPnP exist for the IoT yet.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zeroless</title>
      <link>http://www.x8lucas8x.com/post/zeroless/</link>
      <pubDate>Tue, 18 Aug 2015 20:40:00 +0000</pubDate>
      
      <guid>http://www.x8lucas8x.com/post/zeroless/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;I have been an enthusiast of ZeroMQ for quite some time. If there was an opportunity
that required some sockets on steroids, I would not think twice. Ah, how those three
messaging pattern were useful (i.e. Request/Reply, Push/Pull, Publish/Subscribe).
They had the amazing trait of being able to drastically streamline the development of
distributed systems. And its portability, with wrappers for more than 30 languages,
brokerlessness and amazing documentation made it a no brainer for me to favour ZeroMQ
over other messaging alternatives.&lt;/p&gt;

&lt;p&gt;Using &lt;a href=&#34;http://zeromq.org/&#34;&gt;ZeroMQ&lt;/a&gt; in Python with &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt;, however, always made me feel like I&amp;rsquo;m coding in
C/C++, which I also love by the way. Unfortunately, that lack of &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; API&amp;rsquo;s, if I
may say, &amp;ldquo;pythonicity&amp;rdquo;, just felt wrong to me. And by the end of last January, I
decided to do something about it. So that is how &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt; was born.&lt;/p&gt;

&lt;p&gt;My mission was to leverage on &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; to build a more elegant wrapper for &lt;a href=&#34;http://zeromq.org/&#34;&gt;ZeroMQ&lt;/a&gt;.
Something more aligned with the python way of doing things. And, to a certain degree,
I have succeeded. However, I have never made a comprehensive effort to publicise
&lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt; in any way so, in this post, I hope not only to explain how &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;
differs from &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; but also to reach a greater audience, that may be as enthusiastic
about &lt;a href=&#34;http://zeromq.org/&#34;&gt;ZeroMQ&lt;/a&gt; as myself. Therefore, without further ado, here goes some of the design
decisions I have made for &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;:&lt;/p&gt;

&lt;h5 id=&#34;tcp-only-for-the-win&#34;&gt;TCP only for the win&lt;/h5&gt;

&lt;p&gt;Ok, I know PGM, INPROC and IPC have their use cases. PGM for instance provides a
Publish/Subscribe specific transport, that scales better than TCP in the
Publish/Subscribe use case, as it cut out the ACK flood publishers gets on
every new message. There are also some extra reliability, that you also cannot
find in TCP. IPC, on the other hand, is a pattern agnostic way of providing more
efficient inter-process communication than traditional networking, but is Unix-like
only. As for INPROC&amp;rsquo;s particular case, which efficient applicability is being
hindered by the Python&amp;rsquo;s GIL, I do not see why bother with it.&lt;/p&gt;

&lt;p&gt;Nevertheless, I have a feeling that the vast majority of the users, like myself,
are quite good with just TCP. Which is exactly what you need when building really
horizontally scalable networked services, especially in this time of a renewed
vision for SOA, with microservices having a lot of attention. So let us just use
TCP and free our minds to think about other matters.&lt;/p&gt;

&lt;h5 id=&#34;no-more-contexts&#34;&gt;No more contexts&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; applications require users to create a context, in order to instantiate
sockets. Technically, a context serves as a container for all your sockets and
usually one of it, per process, is just what you need. As a matter of fact, you
could have more, but why bother your runtime with more event loops, for your
socket stuff, when one suffices? Also, if you are using INPROC as transport,
you may also need to share a context for the communication to happen. But again,
if INPROC is is not that useful in Python as aforementioned, do we really need
explicitly manage contexts?&lt;/p&gt;

&lt;p&gt;Not at all, so that is why in &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt; you just have to manage Clients, sockets
that connect, and Servers, sockets that bind, without concerning yourself with
contexts ;). For instance, in order to instantiate a client you would:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;client = Client()

# You could use connect_local(port=12345) as well
client.connect(ip=&#39;127.0.0.1&#39;, port=12345)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, for servers, you would:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;server = Server(port=12345) # No need to call bind here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, note that no real connect/bind will occur unless you instantiate a
messaging pattern, which are the subject of our next topic.&lt;/p&gt;

&lt;h5 id=&#34;like-a-factory-method-pattern&#34;&gt;Like a factory method pattern&lt;/h5&gt;

&lt;p&gt;One thing I never liked about &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; sockets&amp;rsquo;s instantiation is that we have to call
a method called socket, which receives an enum representing the type of the socket.
Why don&amp;rsquo;t they just provide a separate method for every socket possible, like as if
it was a factory method pattern kind of interface. That would allow a more
straightforward experience for developers, that could then rely on their favourite
IDE&amp;rsquo;s code complete to quickly understand what kind of sockets and parameters they
could set. That enum approach, however, will probably make your users go to the
documentation, but solely because of the way the &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt;&amp;rsquo;s interface is.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;, we fixed that, so you don&amp;rsquo;t need to check the documentation every
time you want to instantiate a socket, instead just have a descent code complete
support and you are done. For instance, compare how you would instantiate a
publisher socket with &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pub = Server(port=12345).pub(topic=b&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;connections-awareness&#34;&gt;Connections awareness&lt;/h5&gt;

&lt;p&gt;One of the questions you may ask is to whom your clients are connected to. And
for that, &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; cannot help you. Unless you manage that list off connections by
yourself, you wouldn&amp;rsquo;t be able to get it afterwards. Therefore, in &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;,
we provide an addresses property, so that you can retrieve all your ip and port
pairs as a list of tuples. But that is only for clients of course, as there is
no way to know which sockets are connected to your server without building
some sort of infrastructure for that yourself.&lt;/p&gt;

&lt;h5 id=&#34;subscribe-should-not-be-tricky&#34;&gt;Subscribe should not be tricky&lt;/h5&gt;

&lt;p&gt;In terms of interface, the subscribe case is particularly problematic in &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt;.
One must use the not so intuitive &lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Context.setsockopt&#34;&gt;setsockopt()&lt;/a&gt; method, in
order to define the topics it subscribes to. Like in the following snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;socket = context.socket(zmq.SUB)
socket.setsockopt(zmq.SUBSCRIBE, b&amp;quot;&amp;quot;) # Subscribe to all topics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I believe most new &lt;a href=&#34;http://zeromq.org/&#34;&gt;ZeroMQ&lt;/a&gt;&amp;rsquo;s user get this wrong at first, as they supose no
topic means you are subscribed to all topics, and keep asking himself/herself why
that damn subscriber socket does not receives your published messages.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;, we fixed that, so that you don&amp;rsquo;t have to instantiate your socket
and set something as essential as a topic, in the subscribe case, via some kind
of &amp;ldquo;obscure&amp;rdquo; method. Just compare how you would instantiate a subscriber socket
with &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;listen_for_pub = client.sub(topics=[b&#39;&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;generators-and-high-order-functions-as-first-class-citizens&#34;&gt;Generators and high-order functions as first class citizens&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt; sockets tend to use &lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.send&#34;&gt;send()&lt;/a&gt; and &lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.recv&#34;&gt;recv()&lt;/a&gt; methods
for the message exchange part. However, it always felt wrong to me to do stuff like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;while True:
    data = socket.recv()
    # do something with data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, if Python has built-in support for iterables, or generators if you prefer,
why don&amp;rsquo;t we just do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;listen_for_push = Server(port=12345).pull()

for data in listen_for_push:
    # do something with data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Way more idiomatic to read incoming messages that way, right? As for sending them,
I also followed a different path.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;push = client.push()
push(b&amp;quot;Msg1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Therefore, in &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;, every time you instantiate a message pattern that is
suposed to send messages, use it as a function. Otherwise, treat it as a generator.&lt;/p&gt;

&lt;h5 id=&#34;multi-part-made-easy&#34;&gt;Multi-part made easy&lt;/h5&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt;, if you want to send a multipart message, you have to use the
&lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.recv_multipart&#34;&gt;recv_multipart()&lt;/a&gt; and &lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.html#zmq.Socket.send_multipart&#34;&gt;send_multipart()&lt;/a&gt;
methods. Methods that instead of a single message, will deal with a list of them.
In &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;, I favoured consistency for a quicker and easier learning path,
therefore there is no difference between the singlepart and the multipart API.&lt;/p&gt;

&lt;p&gt;If you want to send a multipart message, just consider that your send function have
a printf like interface and you are set. So, for instance, if you want to send an
id separated from your message body, you could:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;push = client.push()
push(b&#39;1&#39;, b&#39;OK&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally, if someone send you a multipart message, your generator will return a
tuple with all of its parts. As a result of that, to get the message from the previous
example you would need to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;listen_for_push = Server(port=12345).pull()
for id, msg in listen_for_push:
    # do something with id and msg
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;the-future&#34;&gt;The future&lt;/h5&gt;

&lt;p&gt;Although feature parity was never part of my plans, there still some of &lt;a href=&#34;https://github.com/zeromq/pyzmq&#34;&gt;PyZMQ&lt;/a&gt;&amp;rsquo;s
functionalities I would like to provide in &lt;a href=&#34;https://github.com/zmqless/python-zeroless&#34;&gt;Zeroless&lt;/a&gt;. Like both &lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.html#poller&#34;&gt;poller&lt;/a&gt;
and &lt;a href=&#34;https://zeromq.github.io/pyzmq/api/zmq.devices.html&#34;&gt;devices&lt;/a&gt; APIs, for instance. So expect more on the way o/. While
that, if you felt compelled to help shape this project, please clone our &lt;a href=&#34;https://github.com/zmqless/python-zeroless.git&#34;&gt;repository&lt;/a&gt;
and see our &lt;a href=&#34;http://python-zeroless.readthedocs.org/en/latest/development.html#contributing&#34;&gt;guidelines&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>